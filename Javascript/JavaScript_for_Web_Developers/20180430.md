# 20180430. JavaScript Study #1

## 1장. 자바스크립트란 무엇인가

### 1.1 간추린 역사
- 넷스케이프와 마이크로소프트의 경쟁으로 네비게이터의 자바스크립트와 인터넷 익스플로러의 JScript 두 가지 자바스크립트 버전이 존재
- 표준화의 필요성이 대두
- ECMA(European Computer Manufacturers Association)이 표준인 ECMAScript 정의
- 각 브라우저 개발사들은 ECMAScript를 자사 자바스크립트의 구현의 기반으로 삼으려 했으나 완성도는 제각기 달랐다
 
### 1.2 자바스크립트 구현
- JavaScript의 구현은 ECMAScript, DOM, BOM 세 가지로 나뉜다

#### 1.2.1 ECMAScript
- ECMAScript는 언어의 저수준(문법, 타입, 선언문, 키워드, 예약어, 연산자, 객체)에 해당하는 부분을 정의한다    
- 웹 브라우저는 ECMAScript를 구현하는 '호스트 환경'일 뿐이다. 다른 호스트 환경에는 서버 사이드 자바스크립트 플랫폼인 NodeJS 등이 있다

#### 1.2.2 DOM(Document Object Model)
- XML을 HTML에서 사용할 수 있도록 확장한 API    
- 전체 페이지를 노드의 계층 구조로 변환
- DOM API를 통해 노드를 쉽게 제거, 추가, 교체, 수정할 수 있다
- W3C(World Wide Web Consortium)에서 DOM 레벨 1, 2, 3을 표준으로 권고

#### 1.2.3 BOM(Browser Object Model)
- 브라우저 창에 접근하고 조작할 수 있게 하는 인터페이스
- BOM을 주관하는 자바스크립트 표준이 존재하지 않아서 브라우저마다 독자적으로 구현
- HTML5에서 BOM 구현을 명세화하고 있으므로 앞으로는 호환성이 좋아질 것으로 기대

## 2장. HTML 속의 자바스크립트

### 2.1 <script> 요소
- 자바스크립트 코드를 페이지에 직접 작성할 수도 있고(인라인 자바스크립트 코드) 외부 파일에서 불러올 수도 있다
- `<script>`와 `</script>` 태그 사이에 스크립트 코드가 있고 src 속성도 사용했다면 브라우저는 인라인 코드를 무시한다

#### 2.1.1 태그 위치
- 자바스크립트 코드를 모두 `<body>` 요소 안에, 페이지 콘텐츠 마지막에 쓰면 페이지 렌더링은 마친 다음 처리하여 사용자는 페이지가 빠르다고 느낀다

#### 2.1.2 스크립트 처리 지연
- defer 속성(외부 스크립트에만 적용)을 설정하면 코드는 즉시 내려받지만 실행은 지연할 수 있다
- 하지만 일부 브라우저 버전에서는 적용되지않으므로 지연시킬 스크립트는 페이지 맨 마지막에 놓는 편이 여전히 최상이다

### 2.2 인라인 코드와 외부 파일
- 자바스크립트는 외부 파일로 분리하는 방법이 더 좋다. 외부 파일을 쓰면 좋은점은
  1. 관리가 쉽다
  2. 캐싱
  3. 미래에도 안전하다
 
### 2.4 `<noscript>` 요소
- noscript 요소를 쓰면 해당 콘텐츠는 브라우저가 스크립트를 지원하지 않거나 비활성화되었을 때만 표시된다

## 3장. 언어의 기초

### 3.1 문법

#### 3.1.2 식별자
- 식별자는 카멜 케이스로 쓰는것을 권장

#### 3.1.4 스트릭트 모드
- 전체 스크립트에 스트릭트 모드를 적용하려면 스크립트 맨 위에 "use strict"; 추가

#### 3.1.5 문장
- 각 문장이 끝날때는 항상 세미콜론을 쓰는것을 권장(압축 시 문법 에러가 발생할 수 있다)
- 제어문에서는 항상 코드 블록({ })을 쓰는것을 권장

### 3.2 키워드와 예약어
- 키워드와 예약어는 식별자나 프로퍼티 이름으로 쓰지않는 것을 권장

### 3.3 변수
- ECMAScript는 느슨한 변수 타입을 사용하는데, 이 말은 변수에 어떤 타입의 데이터라도 저장할 수 있다는 의미
    - 예제와 같이 변수의 데이터 타입을 바꾸는 것은 유효하지만 권장하지 않는다
~~~javascript
var message = "hi";
message = 100;
~~~

- var 연산자는 변수를 로컬 스코프에서 정의하며, var 연산자를 생략하면 변수를 전역으로 정의할 수 있다.
    - 하지만 전역 변수를 로컬에서 정의하면 관리하기 어려우므로 권장하지 않는다
    - strict 모드에서는 var 연산자를 생략하고 변수를 정의하면 ReferenceError가 발생한다

### 3.4 데이터 타입
#### 3.4.1 typeof 연산자
- typeof 연산자를 통해 데이터 타입을 알 수 있다
    - 정의되지 않은 변수: "undefined"
    - 불리언: "boolean"
    - 문자열: "string"
    - 숫자: "number"
    - 함수를 제외한 객체 또는 null: "object"
        - null은 빈 객체를 참조하는 특별한 값이므로 "object"
    - 함수: "function"
    
#### 3.4.2 undefined 타입
- 변수를 초기화하지 않으면 자동으로 undefined가 할당되지만 변수는 항상 초기화하는 것을 권장
    - 정의되지 않은 변수와 초기화되지 않은 변수는 기술적으로 크게 다르지만 typeof 연산자는 "undefined" 라는 결과를 똑같이 반환한다
    
#### 3.4.3 Null 타입
- null은 빈 객체를 가리키는 포인터
- 변수를 정의할 때 객체를 사용해야 하지만 해당 객체를 이용할 수 없을 때는 null로 초기화하는 것을 권장
- 아래와 같이 해당 변수가 객체를 가리키는지 명시적으로 확인 가능
~~~javascript
if(car =! null) {
    // car를 사용하는 코드
}
~~~
~~~javascript
null == undefined
null === undefined
~~~

#### 3.4.4 불리언 타입
- true와 false는 대소문자를 구분한다

#### 3.4.5 숫자 타입
~~~javascript
var intNum = 55;    // 10진수
var octalNum = 070; // 8진수, strict mode에서는 허용하지 않는다
var hexNum = 0xA;   // 16진수, 대소문자 구별 없음
~~~

~~~javascript
var floatNum1 = 0.1;
var floatNum2 = .1;  // 유효하지만 권장하지 않는다
~~~

- NaN(Not a Number)는 숫자를 반환할 것으로 의도한 조작이 실패했을 때 반환하는 값으로 에러는 아니다
    - isNaN() 함수: 매개변수를 하나 받아 해당 값이 '숫자가 아닌 값'인지 검사
    
#### 3.4.6 문자열 타입
- 문자열에 2바이트 문자가 들어있다면 length 프로퍼티가 문자열 길이를 정확히 반환하지 못 할 수도 있다

### 3.5 연산자

#### 3.5.1 단항 연산자
- 단 하나의 값에만 적용되는 연산자
- ++num vs num++
~~~javascript
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;   // 21
var num4 == num1 + num2;    // 21

var num3 = num1-- + num2;   // 22
var num4 == num1 + num2;    // 21
~~~

#### 3.5.7 동일 연산자
- 동일 연산자: ==, 비동일 연산자: !=
- 일치 연산자: ===, 불일치 연산자: !== 
    - 동일/비동일 연산자를 쓰면 타입 변환 때문에 자주 문제가 발생하므로, 일치/불일치 연산자 사용 권장
    
#### 3.5.8 삼항 연산자
~~~javascript
variable = boolean_expression ? true_value : false_value;

var max = (num1 > num2) ? num1 : num2;  // num1과 num2 중 큰 값이 max에 저장
~~~

#### 3.6.8 with 문
- with문은 성능에 악영향이 있으며 이를 포함한 코드는 디버그하기도 어려우므로 권장하지 않는다

